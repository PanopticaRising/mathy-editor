/**
 * This is a Context that manages persisting saved information about the problem.
 */

import _ from "lodash";
import { createContext, Dispatch, Reducer, useCallback, useContext, useEffect, useReducer } from "react";
import { ComponentPlugin, ComponentPluginState } from "../ComponentPlugin";
import { useVarValueFunction } from "../../Utilities/Helpers/SubmissionHelpers";
import { VarPluginContext } from "./VarPluginProvider";

type UniqueName = string;

// This will be collated into a JSON file that can recreate a problem.
export interface SavedData {
    Components: SavedComponentData[],
    Variables: SavedComponentData[],
    Code: CodeBlockData,
    // This is a hack for react-beautiful-dnd, which doesn't provide nesting support.
    editFocus?: UniqueName;
}

export enum SUPPORTED_CODING_TYPES {
    PYTHON,
    JAVASCRIPT
}

export type CodeBlockData = {
    [uniqueName: string]: { lang: SUPPORTED_CODING_TYPES; code: unknown } | undefined;
}

// TODO: Move to a more central location.
export type Customizations = {
    [x: string]: any,
}

/**
 * The saved representation of a Component is:
 * 1) A reference to the Plugin code used to instantiate the component. This is what the DnDManager knows as ['name', result.draggableId].
 * 2) The scoped customization code.
 * 3) A unique name to differentiate multiple instances of the same Component type.
 *      For a Component, this is autogenerated, but for variables, it should be human-readable.
 */
export interface SavedComponentData {
    name: string;
    uniqueName: UniqueName;
    customizations: Customizations
    parent?: UniqueName;
}

type SaveActions =
    // Component Actions
    | { type: 'AddNewComponent', component: SavedComponentData, newIndex: number, parent?: UniqueName }
    | { type: 'UpdateComponent', uniqueName: UniqueName, customization: Customizations }
    | { type: 'ReorderComponent', startIndex: number, newIndex: number, parent?: UniqueName }
    | { type: 'DeleteComponent', uniqueName: UniqueName }
    // Variable Actions
    | { type: 'AddNewVariable', variable: SavedComponentData }
    | { type: 'UpdateVariable', uniqueName: UniqueName, customization: Customizations }
    | { type: 'DeleteVariable', uniqueName: UniqueName }
    // Code Actions
    | { type: 'SaveCode', uniqueName: UniqueName, code: unknown }
    | { type: 'ChangeCodeLang', uniqueName: UniqueName, lang: SUPPORTED_CODING_TYPES }
    | { type: 'SubmitAnswers', uniqueName: UniqueName, }
    // Utility Actions
    | { type: 'Download' }
    | { type: 'Load', json: SavedData }
    | { type: 'ShiftEditFocus', uniqueName?: UniqueName }
    | { type: 'Debug' }

const reorder = (list: SavedComponentData[], startIndex: number, endIndex: number) => {
    const result = Array.from(list);
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);

    return result;
};

// A quick hack from StackOverflow to download this.
export function downloadObjectAsJson(exportObj: SavedData, exportName: string) {
    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj));
    var downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", exportName + ".json");
    document.body.appendChild(downloadAnchorNode); // required for firefox
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function reducer(state: SavedData, action: SaveActions): SavedData {
    console.log(`Recieved action for ${action.type}`, action);
    switch (action.type) {
        case "AddNewComponent":
            if (action.parent) {
                // TODO: This does not account for multi-nested objects.
                //       I think in the future, Components should become a flat array, and a new object
                //       should be made to store Layout information.
                const parent = findByUniqueName(state, action.parent);
                if (!parent) {
                    throw new Error('Could not find parent ' + parent);
                }

                console.log(action.component.uniqueName, action.component.customizations);
                console.log(JSON.stringify(action.component));

                if (parent.customizations.children && parent.customizations.children.length > 0) {
                    parent.customizations.children.splice(action.newIndex, 0, action.component)
                } else {
                    parent.customizations.children = [action.component];
                }
            } else {
                state.Components.splice(action.newIndex, 0, action.component);
            }

            console.log(state);
            return { ...state };
        case "AddNewVariable":
            state.Variables.push(action.variable);
            return { ...state };
        case "UpdateComponent":
            const component = findByUniqueName(state, action.uniqueName);
            if (!component) {
                throw new Error('Could not find a component to update.');
            }
            component.customizations = action.customization;
            return { ...state };
        case "UpdateVariable":
            // TODO: Implement
            const variable = _.find(state.Variables, ['uniqueName', action.uniqueName])
            if (!variable) {
                console.error('Could not find variable to update', variable);
                throw new Error('Could not find variable to update');
            }
            variable.customizations = action.customization;

            return { ...state };
        case "ReorderComponent":
            if (action.parent) {
                const parent = findByUniqueName(state, action.parent);
                if (!parent) {
                    throw new Error("Could not find the parent " + action.parent);
                }
                parent.customizations.children = reorder(parent.customizations.children, action.startIndex, action.newIndex);
            } else {
                state.Components = reorder(state.Components, action.startIndex, action.newIndex);
            }

            return { ...state };
        case "DeleteComponent":
            _.remove(state.Components, ['uniqueName', action.uniqueName]);
            return { ...state };
        case "DeleteVariable":
            _.remove(state.Variables, ['uniqueName', action.uniqueName]);
            return { ...state };
        case "ChangeCodeLang":
            state.Code[action.uniqueName] = { code: {}, ...state.Code[action.uniqueName], lang: action.lang }
            return { ...state };
        case "SaveCode":
            state.Code[action.uniqueName] = { lang: SUPPORTED_CODING_TYPES.PYTHON, ...state.Code[action.uniqueName], code: action.code }
            return { ...state };
        case "Download":
            downloadObjectAsJson(state, 'sample-problem');
            return state;
        case "Load":
            return action.json;
        case "ShiftEditFocus":
            return { ...state, editFocus: action.uniqueName }
        case "Debug":
            console.log(state);
            return state;
        default:
            return state;
    }
}

const emptySaveState = { Components: [], Variables: [], Code: {} };

export const SaveStateContext = createContext<{ dispatch?: Dispatch<SaveActions>, state: SavedData, findInComponentTreeByUniqueName?: (u: string) => SavedComponentData | null }>({ state: emptySaveState });

/**
 * Pass in your component's uniqueName to access scoped storage.
 */
export function useComponentCustomization<T extends Customizations>(uniqueName: string, mode?: ComponentPluginState) {
    const { dispatch, findInComponentTreeByUniqueName } = useContext(SaveStateContext);
    const getVarValue = useVarValueFunction();
    const component = findInComponentTreeByUniqueName?.(uniqueName);

    if (!component) {
        throw new Error('Could not find component in state.');
    }

    let customizationState = component.customizations as T;

    const interpolate = (val: unknown): string | object | unknown => {
        if (typeof val === "string") {
            const RE = /\$\{(\S+?)\}/gi;
            const RE2 = /\$\{(\S+)\}/i;
            return _.replace(val, RE, (match: string, ...args: any[]) => {
                const varName = match.match(RE2);
                if (!varName || varName.length < 1) return '(PARSING ERROR)';

                const varNameStr = varName[1];

                return (getVarValue(varNameStr) as any).toString();
            })
        } else if (typeof val === "object") {
            return _.mapValues(val, interpolate);
        } else {
            return val;
        }
    }

    if (mode === ComponentPluginState.LOCKED) {
        customizationState = _.mapValues(customizationState, interpolate) as T;
    }

    return {
        updateState: (customizations: T): void => {
            // TODO: Run through the customizations, look for interpolable variables, replace them with a fancy Pyodide-calculated object?
            dispatch?.({ type: 'UpdateComponent', uniqueName: uniqueName, customization: customizations });
        },
        state: customizationState,
    }
}

export function useVariableCustomization<T extends Customizations>(uniqueName: string) {
    const { dispatch, state } = useContext(SaveStateContext);

    const variable = _.find(state.Variables, ['uniqueName', uniqueName]);

    console.log('Found variable: ', variable);

    if (!variable) {
        throw new Error('Could not find variable in state.');
    }

    return {
        updateState: (customizations: T): void => {
            // TODO: Run through the customizations, look for interpolable variables, replace them with a fancy Pyodide-calculated object?
            dispatch?.({ type: 'UpdateVariable', uniqueName: uniqueName, customization: customizations });
        },
        state: variable.customizations as T,
    }
}


// This function is going to be used by the Code editor? In my code, not plugin code.
// I need a hook that will registerCodeBlock to be used by LayoutPlugins/ButtonPlugins that will
//   1) Create a code block in the Coder screen and
//   2) Inform the LayoutPlugin of the answer so that: (RE: 2, The StudentInputManager should handle that, this should only be for creation.)
//      a) The problem can be reported as solved
//      b) The next steps of the problem can be shown
//      c) Hints or other conditional actions can be initiated.
// vvvvvvvvvvvvvvvvvvvvvvvvvvvvv------------------------------------------------------------------------------------------------
// When in Teacher View, a LayoutPlugin should indicate that a Code Block is necessary.
// When in Student View, a LayoutPlugin should indicate that a Code Block is _available to submit against_.

const DEFAULT_PYTHON_CODE = {
    "doc": "print(\"hello world\")",
    "selection": {
        "ranges": [
            {
                "anchor": 0,
                "head": 0
            }
        ],
        "main": 0
    }
};

// This function creates a new code block in the Code tab. 
export function useCodeBlock(uniqueName: string) {
    const { dispatch, state } = useContext(SaveStateContext);

    useEffect(() => {
        const codeBlock = state.Code[uniqueName];

        if (!codeBlock) {
            // Code block hasn't been initialized yet. Should bootstrap.
            console.debug('Initializing code block for ' + uniqueName);
            dispatch?.({ type: 'SaveCode', code: DEFAULT_PYTHON_CODE, uniqueName: uniqueName })
        }
        // Avoid re-initializing if the state changes.
        // eslint-disable-next-line react-hooks/exhaustive-deps 
    }, [dispatch, uniqueName]);


    return {
        saveCode: (code: unknown, lang: SUPPORTED_CODING_TYPES): void => {
            dispatch?.({ type: 'SaveCode', uniqueName, code });
        },
        submitAnswers: () => dispatch?.({ type: 'SubmitAnswers', uniqueName, })
    }
}

const findByUniqueName = (state: SavedData, uniqueName: UniqueName) => {
    const matchUniqueName = (accum: null | SavedComponentData, comp: SavedComponentData, ind: number) => {
        if (comp.uniqueName === uniqueName) return comp;
        if (comp.customizations.children) return comp.customizations.children.reduce(matchUniqueName, null);
        return accum;
    }

    return state.Components.reduce(matchUniqueName, null);
}

export const SaveStateProvider: React.FC = ({ children }) => {
    const [state, dispatch] = useReducer<Reducer<SavedData, SaveActions>>(reducer, emptySaveState);

    const findInComponentTreeByUniqueName = _.partial(findByUniqueName, state);

    // Debug
    (window as any).SaveStateProvider = dispatch;
    (window as any).loadProblem = async (filename: string) => {
        const res = await fetch(`${window.location.origin}/examples/${filename}.json`);
        const json = await res.json();
        console.log(json);
        dispatch({ type: 'Load', json: json });
    }

    return <SaveStateContext.Provider value={{ dispatch, state, findInComponentTreeByUniqueName }}>
        {children}
    </SaveStateContext.Provider>
}