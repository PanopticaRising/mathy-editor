/**
 * This is a Context that manages persisting saved information about the problem.
 */

import _, { uniq } from "lodash";
import { createContext, Dispatch, Reducer, useContext, useReducer } from "react";

// This will be collated into a JSON file that can recreate a problem.
interface SavedData {
    Components: SavedComponentData[],
    Variables: SavedComponentData[],
}

// TODO: Move to a more central location.
export type Customizations = {
    [x: string]: any,
}

/**
 * The saved representation of a Component is:
 * 1) A reference to the Plugin code used to instantiate the component. This is what the DnDManager knows as ['name', result.draggableId].
 * 2) The scoped customization code.
 * 3) A unique name to differentiate multiple instances of the same Component type.
 *      For a Component, this is autogenerated, but for variables, it should be human-readable.
 */
interface SavedComponentData {
    name: string;
    uniqueName: string;
    customizations: Customizations
}

type SaveActions = | { type: 'AddNewComponent', component: SavedComponentData, newIndex: number }
    | { type: 'UpdateComponent', uniqueName: string, customization: Customizations }
    | { type: 'ReorderComponent', startIndex: number, newIndex: number }
    | { type: 'AddNewVariable', variable: SavedComponentData }
    | { type: 'UpdateVariable', variable: SavedComponentData }
    | { type: 'DeleteComponent', uniqueName: string }
    | { type: 'DeleteVariable', uniqueName: string }
    | { type: 'Download' }
    | { type: 'Load', json: SavedData }

const reorder = (list: SavedComponentData[], startIndex: number, endIndex: number) => {
    const result = Array.from(list);
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);

    return result;
};

export function downloadObjectAsJson(exportObj: SavedData, exportName: string) {
    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj));
    var downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", exportName + ".json");
    document.body.appendChild(downloadAnchorNode); // required for firefox
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function reducer(state: SavedData, action: SaveActions): SavedData {
    console.log(`Recieved action for ${action.type}`);
    switch (action.type) {
        case "AddNewComponent":
            state.Components.splice(action.newIndex, 0, action.component);
            return { ...state };
        case "AddNewVariable":
            state.Variables.push(action.variable);
            return { ...state };
        case "UpdateComponent":
            const component = _.find(state.Components, ['uniqueName', action.uniqueName]);
            if (!component) {
                throw new Error('Could not find a component to update.');
            }
            component.customizations = action.customization;
            return { ...state };
        case "UpdateVariable":
            _.find(state.Variables, ['uniqueName', action.variable.uniqueName])
            return { ...state };
        case "ReorderComponent":
            state.Components = reorder(state.Components, action.startIndex, action.newIndex);
            return { ...state };
        case "DeleteComponent":
            _.remove(state.Components, ['uniqueName', action.uniqueName]);
            return { ...state };
        case "DeleteVariable":
            _.remove(state.Variables, ['uniqueName', action.uniqueName]);
            return { ...state };
        case "Download":
            downloadObjectAsJson(state, 'sample-problem');
            return state;
        case "Load":
            return action.json;
        default:
            return state;
    }
}

const emptySaveState = { Components: [], Variables: [] };

export const SaveStateContext = createContext<{ dispatch?: Dispatch<SaveActions>, state: SavedData }>({ state: emptySaveState });

/**
 * Pass in your component's uniqueName to access scoped storage.
 */
// TODO: Make a unique type for uniqueName to prevent accidental misuse.
export function useComponentCustomization<T extends Customizations>(uniqueName: string) {
    const { dispatch, state } = useContext(SaveStateContext);

    const component = _.find(state.Components, ['uniqueName', uniqueName]);

    if (!component) {
        throw new Error('Could not find component in state.');
    }

    return {
        updateState: (customizations: T): void => {
            dispatch?.({ type: 'UpdateComponent', uniqueName: uniqueName, customization: customizations });
        },
        state: component.customizations,
    }
}

export const SaveStateProvider: React.FC = ({ children }) => {
    const [state, dispatch] = useReducer<Reducer<SavedData, SaveActions>>(reducer, emptySaveState);

    // Debug
    (window as any).SaveStateProvider = dispatch;

    return <SaveStateContext.Provider value={{ dispatch, state }}>
        {children}
    </SaveStateContext.Provider>
}